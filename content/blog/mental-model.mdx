---
title: "Running React on different Platforms"
description: "The correct mental model for understanding React across platforms"
date: "2026-02-03"
topic: "React"
---

React has been dominating frontend for years now. It‚Äôs everywhere web apps, 
mobile apps, even TVs. But the crazy thing isn‚Äôt just where React runs. It‚Äôs 
how everything else started building around it. Whole frameworks exist because of React

<img src="/react/meme.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

To be honest I have been using React for years without even understand what it really is, I knew there exist a react-native
for building mobile apps and there exists a tons of other react libraries for building on different platform. But I never
really tried understanding how people are using React on different platforms but my doubt of HOW got clear when i understood
what react truly is. 

if you are little curious to know how react is running on different platform then this blog is for you. 
we build a mental model for what react is and we will unwrap little things here and later we will get glimpse of some core react internal along 
the way



# UI as tree

We all know React is a UI library, but let's step back and think _what exactly *is* UI?_

You might say it's the visual surface we interact with: buttons, links, colors, images, layouts, icons, and more. It consists
of different UI elements.

<img src="/react/apple.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

For the **web**, we use HTML tags like `<div>`, `<button>`, `<a>`, `<img>` to create UI elements

```html
<div class="card">
  <img src="avatar.png" alt="User" />
  <button>Follow</button>
</div>
```

For **mobile apps**, we have native components like `View`, `Pressable`, and `Text`

```tsx
<View style={styles.card}>
  <Image source={avatar} />
  <Pressable onPress={handleFollow}>
    <Text>Follow</Text>
  </Pressable>
</View>
```

When working with UI we always have this one pattern in common either you are building a mobile app, web app or anything

it's the hirecy between the UI elements, you have `button`, `img` inside `div` or `Image` `Pressable` inside `View` they all
form a tree like structure.

 <UserCardDemo/>

```zsh
Card
 ‚îú‚îÄ CardContent
 ‚îÇ    ‚îî‚îÄ p
 ‚îî‚îÄ CardFooter
      ‚îú‚îÄ Avatar
      ‚îú‚îÄ UserInfo
      ‚îÇ    ‚îú‚îÄ CardTitle
      ‚îÇ    ‚îî‚îÄ CardDescription
      ‚îî‚îÄ StarIcon

```
Every UI element can be created, updated, or removed using platform-specific imperative APIs. For example, the DOM uses `appendChild`, while iOS uses `addSubview`.
Each platform exposes its own APIs for managing UI elements.




<Sandpack
  template="react"
  files={{
    "/App.js": `import { useState } from "react";

export default function CounterApp() {
  const [count, setCount] = useState(0);
  return (
    <div className="container">
      <div className="counter">
        <h3>Counter App</h3>
        <Text count={count} />
      </div>
      <div className="buttons">
        <button 
          className="decrement"
          onClick={() => setCount(count - 1)}
        >
          Decrement
        </button>
        <button 
          onClick={() => setCount(count + 1)}
        >
          Increment
        </button>
      </div>
    </div>
  );
}

function Text({ count }) {
  return <span className="count">Count: {count}</span>;
}
`,
    "/styles.css": `.container {
  display: flex;
  flex-direction: column;
  gap: 24px;
  padding: 32px;
  font-family: system-ui, sans-serif;
  max-width: 320px;
  margin: 0 auto;
  align-items: center;
}

.counter {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}

h3 {
  margin: 0;
  color: #666;
  font-size: 1.125rem;
  font-weight: 500;
}

.count {
  font-size: 1.5rem;
  font-weight: 700;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 16px;
}

button {
  padding: 8px 16px;
  border-radius: 6px;
  border: 1px solid #e2e8f0;
  background: white;
  color: #0f172a;
  font-weight: 500;
  cursor: pointer;
  transition: all 0.2s;
}

button:hover {
  background: #f8fafc;
  border-color: #cbd5e1;
}

button.decrement {
  color: #ef4444;
  border-color: #fee2e2;
  background: #fef2f2;
}

button.decrement:hover {
  background: #fee2e2;
  border-color: #fca5a5;
}
`
  }}
/>

In the above example, if you take a look we have a `Text` component and a `CounterApp` component, we are passing `count` into a `Text` component via _props_

React already has already made a UI tree with itself in memory when initially components where mount, it has all information about your UI from tip to tail in a complex 
data structure called `fiber`, your each DOM node is represented as `FiberNode` internally


```tsx 
function FiberNode(
  this: $FlowFixMe,
  tag: WorkTag,        // Type of Fiber (FunctionComponent, ClassComponent, HostComponent, etc.)
  pendingProps: mixed, // New props waiting to be applied
  key: ReactKey,       // Unique key used for reconciliation in lists
  mode: TypeOfMode,    // Fiber mode (ConcurrentMode, StrictMode, etc.)
) {
  this.tag = tag; // Fiber type
  this.key = key;// React key for reconciliation
  this.elementType = null; // Original element type (JSX type)
  this.type = null;  // Resolved component type (function/class/host)

  this.return = null;  // Parent Fiber
  this.child = null;   // First child Fiber
  this.sibling = null; // Next sibling Fiber

  ...

  this.updateQueue = null; // Queue of state updates (class components)
  this.memoizedState = null; // State from last render (functional components)

  ...
}


```
When you click the Increment button in the CounterApp, you are basically calling `setCount` function to increment the value. React notices that the state has changed. üßê
It then re-runs the affected components to build a new updated UI tree in memory, representing how the UI should look now.

```bash
Before click (count = 0)

CounterApp
 ‚îú‚îÄ h3: "Counter App"
 ‚îî‚îÄ Text
      ‚îî‚îÄ span: "Count: 0"
```

React then ‚Äúcompares snapshots‚Äù: the new UI tree(fiber) vs the old UI tree(fiber). It quickly figures out what actually changed. In this case, only the Text component‚Äôs span needs to update  everything else is the same.

```bash 
After click (count = 1)

CounterApp
 ‚îú‚îÄ h3: "Counter App"
 ‚îî‚îÄ Text
      ‚îî‚îÄ span: "Count: 1"
```
up intill this point we have nothing to do with DOM manupliation, we are just playing with that complex 
fiber data structure which is a look alike of our UI, when we compared two UI tree and figured out 
_only the Text component‚Äôs span needs to update  everything else is the same_.

Now we only know what to do but we haven't done it yet So out next step is making change in the DOM now

Notice that the screen still shows the old value at this point:


<img src="/react/oldui.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

React then uses the platform specific APIs in our case DOM, to bring the UI on the screen in sync with the new tree:

```js
textNode.nodeValue = "1"

```


<img src="/react/newui.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


from what we saw, we can guess one thing react is working on two phases
- comparing old UI tree and new UI tree and finding the difference, what changed
- making change in the dom

## Why do diffing ? 

Why check two UI trees? if we already have a new updated UI tree why not just make a UI using that? why need
to check the difference?

Because creating UI from scratch means we are adding DOM elements again on screen which is a heavy operation, 
browser have to go through style re-calculation, layout(reflow), re-paint, compositing etc 

Read _[How Browsers Work](https://developer.mozilla.org/en-US/docs/Web/Performance/Guides/How_browsers_work)_

It's not just about single element if we have complex UI then we would need to create thousands of DOM nodes again

<img src="/react/chess.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


This is where the diffing algorithm comes in. It finds the minimal part of the UI that needs updating so we are not unnecessaryly doing things

> Remember this part clearly, it first finds what needs to be change and then go and make changes on screen.

## What if no React ?
React is a declarative UI library that automatically syncs application state with the rendered UI.

```js 
const el = document.createElement("div")
el.textContent = count
document.body.appendChild(el)

button.addEventListener("click", () => {
  count++
  el.textContent = count
})

```

if you were to use the DOM APIs you were responsible for  
- creating elements
- updating text
- wiring updates
- keeping everything in sync

but with our above counter app we never did that right? we didn't care about creating element, finding element, updating text node, React did that for us


you only say "_When state is `count`, the UI should look like this_". React will figure out when to re-render, 
what changed, how to update the real UI. We will discuss in depth how it does and everything in later 
blog in this series


## Summary

UI on any platform forms a tree like structure. React keeps its own version of this UI tree in memory.

When state changes, React first builds a new tree, compares it with the old one, and figures out what actually changed. Only then does it use platform specific APIs to update the real screen.

This is how React keeps your data and UI in sync, without you manually touching the DOM or native APIs.


# React in Two Parts

Let's divide react into two parts

<img src="/react/two parts.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

-  **Reconciler**  the diffing algorithm
- **Host Instance**  the platform-specific renderer

This distinction is important for us to understand how react is working on multiple platforms, and how react is
just not a UI library but it's a _UI as a runtime_

<img src="/react/ui-runtime.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

If you check the [react source code](https://github.com/facebook/react/tree/main/packages), there is a two seperate packages `react-reconciler` and `react-dom`

<img src="/react/react-source-code.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


# react-reconciler

Now this reconciler package consist for handling your props, state, effects, lifecycles, concurrent mode, context etc it re-runs your component and builds a new UI tree, compare it with old one and come with an effects(decission): update this text, remove this div, insert that button etc  It doesn't do anything with the DOM node

<img src="/react/difference.jpg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />






# react-dom (host Instance)

Host instance is the underlying DOM node (or native view in React Native) that React manages. 

All the time i have been talking about UI elements, UI elements it's not but just a host instance.

Host instance can be anything, either DOM nodes or [native view]() or [PDF primitives](https://react-pdf.org) it can be anything depending  on the platform we are.

# Split

This split helps us to re-use the Reconcilation logic on different platform as well, it's like _hey I know what to
update, when to update, how efficiently update let that on me, you(host renderer) just tell me how can i create, update, delete UI elements for your platform, just give me those APIs_

it becomes learn once 
and apply everywhere. you can use same hooks `useState` `useEffect` same function component and same logic but on different platform where your UI is not a DOM node rather native mobile component, or canvas or anything

It's like we have two puzzle pieces, 

<img src="/react/host.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />



<img src="/react/connected.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

