---
title: "Running React on different Platforms"
description: "The correct mental model for understanding React across platforms"
date: "2026-02-03"
topic: "React"
---

We build web apps with React. We build mobile apps with React. We even build 3D apps with React. And yet,
we write the same kind of code everywhere the same `useState` and `useEffect` hooks, the same function components,
the same mental model.

Now this raises an interesting question ü§î: how does the same React code run on such different platforms? A web app uses the DOM, a mobile
app uses native views, and a 3D app might use canvas or WebGL. These systems have completely different
ways of drawing UI.

<img src="/react/meme.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

I have been using React for years without even understanding what it really is. I knew about React Native for building mobile apps, and there are a ton of other React libraries for different platforms, but I never really tried to understand how people were using React across platforms. My curiosity about how it all works was finally satisfied when I understood what React truly is.

For this blog i just want to shape the mental model of what react is without giving too much about react internals.

If you are a little curious about how React runs on different platforms,
then this blog is for you. We will build a mental model for what React is, unwrap small pieces step by step.

# UI as tree

We all know React is a UI library, but let's step back and think *what exactly *is* UI?*

You might say it's the visual surface we interact with: buttons, links, colors, images, layouts, icons, and more. It consists
of different UI elements.

<img src="/react/apple.png" alt="Apple UI example" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

For the **web**, we use HTML tags like `<div>`, `<button>`, `<a>`, `<img>` to create UI elements

```html
<div class="card">
  <img src="avatar.png" alt="User" />
  <button>Follow</button>
</div>
```

For **mobile apps**, we have native components like `View`, `Pressable`, and `Text`

```tsx
<View style={styles.card}>
  <Image source={avatar} />
  <Pressable onPress={handleFollow}>
    <Text>Follow</Text>
  </Pressable>
</View>
```

When working with UI, we always see the same pattern, whether we are building a mobile app, web app, or anything else: the **hierarchy between UI elements**. 
You have `button` and `img` inside a `div` or `Image` and `Pressable` inside a `View`; they all form a tree-like structure.

<UserCardDemo/>

```zsh
Card
 ‚îú‚îÄ CardContent
 ‚îÇ    ‚îî‚îÄ p
 ‚îî‚îÄ CardFooter
      ‚îú‚îÄ Avatar
      ‚îú‚îÄ UserInfo
      ‚îÇ    ‚îú‚îÄ CardTitle
      ‚îÇ    ‚îî‚îÄ CardDescription
      ‚îî‚îÄ StarIcon
```


To understand more things let's first understand how react is structured

# React in Two Parts

React can be thought of as **two separate pieces**:

<img src="/react/two parts.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

* **Reconciler** ‚Äì the part that compares UI trees and decides what needs to change (diffing algorithm)
* **Host Instance** ‚Äì the platform-specific renderer (DOM nodes, native views, etc.)

This distinction is crucial for understanding how React works across multiple platforms. React is not just a UI library; it‚Äôs more like a **UI runtime**.

<img src="/react/ui-runtime.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

If you check the [React source code](https://github.com/facebook/react/tree/main/packages), you‚Äôll see two separate packages: `react-reconciler` and `react-dom`.
these two packages are the one you use to build your web apps

<img src="/react/react-source-code.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

# react-reconciler

The reconciler handles your props, state, effects, lifecycles, concurrent mode, context, etc. Reconciler is the brain of react, it does all
the magic calculation and give the output to renderer

Let's look at an example

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function CounterApp() {
const [count, setCount] = useState(0);
return ( <div className="container"> <div className="counter"> <h3>Counter App</h3> <Text count={count} /> </div> <div className="buttons">
<button
className="decrement"
onClick={() => setCount(count - 1)}
>
Decrement </button>
<button
onClick={() => setCount(count + 1)}
>
Increment </button> </div> </div>
);
}

function Text({ count }) {
return <span className="count">Count: {count}</span>;
}
`,
    "/styles.css": `.container {
display: flex;
flex-direction: column;
gap: 24px;
padding: 32px;
font-family: system-ui, sans-serif;
max-width: 320px;
margin: 0 auto;
align-items: center;
}

.counter {
display: flex;
flex-direction: column;
align-items: center;
gap: 8px;
}

h3 {
margin: 0;
color: #666;
font-size: 1.125rem;
font-weight: 500;
}

.count {
font-size: 1.5rem;
font-weight: 700;
font-family: monospace;
}

.buttons {
display: flex;
gap: 16px;
}

button {
padding: 8px 16px;
border-radius: 6px;
border: 1px solid #e2e8f0;
background: white;
color: #0f172a;
font-weight: 500;
cursor: pointer;
transition: all 0.2s;
}

button:hover {
background: #f8fafc;
border-color: #cbd5e1;
}

button.decrement {
color: #ef4444;
border-color: #fee2e2;
background: #fef2f2;
}

button.decrement:hover {
background: #fee2e2;
border-color: #fca5a5;
}
`
}}
/>

In this example, we have a `Text` component and a `CounterApp` component. We are passing count into the `Text` component via props.

when you first run this code, reconciler internally makes a UI tree for itself, it has no idea about the DOM. It just took your jsx components 
files and built a UI tree 

for those of you who has some idea of react internals, yes it's the `fiber` object

<img src="/react/card.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

When state updates happen, React continues to work only with this in-memory UI tree. It does not directly touch the DOM while figuring out what changed.


<img src="/react/clicked.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


When you click the `increment` button you just called a `setCount` function to change the state. what we did here is just 
we requested to the reconciler to re-render our component. well you don't directly request to reconciler through your code it's just the 
how internally works. all you did is just called `setCount` function and what's what triggered the re-render


now reconciler will create a new updated UI tree re-running your relavent component with new state value.

<img src="/react/cardnew.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

once the new UI tree is created it compares the old UI tree and new UI tree

<img src="/react/compare.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />


after the comparession it comes with the conolusion(effects), _we have everything same, `button`, `h3` and other component looks fine so we don't need to touch them 
only the text in the span tag needs an update_ 

reconciler just came with a list of effects need to be done on DOM but it itself doesn't do that, if you notice it doesn't even know there is something called `DOM` it's just happy with it's in 
memory UI tree



# react-dom (Host Renderer)

Now, once we have the list of effects, _what to dos_ it's the work of host-renderer to take those effects and apply them.

Every UI element can be created, updated, or removed using **platform-specific imperative APIs**. For example, the DOM uses `appendChild`, while iOS uses `addSubview`.

react-dom uses the DOM APIs to work with those effects given by the reconciler, it does the work of updating text removing element or creating an element
in our example we simply update the `textNode` in the `span` tag

```js
textNode.nodeValue = "1"
```

The host instance is the actual DOM node (or native view in React Native) that React manages. Depending on the platform, the host instance can be:

* DOM nodes (Web)
* Native views (iOS/Android)
* PDF primitives ([React PDF](https://react-pdf.org))
* Canvas, WebGL, or anything else

# Why this split matters

This separation allows React to reuse the same reconciliation logic across platforms. Think of it like this:

_I know what changed. how to update effectively what needs to be done, i will give you the list of work to be done on UI, you host-renderer do the rest_

This is why you can **use the same hooks (`useState`, `useEffect`) and function components everywhere**, whether the platform is DOM, mobile native components, or canvas.


## react-ink

react-link is a another react-renderer for building a terminal apps

```tsx 

import React, {useState, useEffect} from 'react';
import {render, Text} from 'ink';

const Counter = () => {
	const [counter, setCounter] = useState(0);

	useEffect(() => {
		const timer = setInterval(() => {
			setCounter(previousCounter => previousCounter + 1);
		}, 100);

		return () => {
			clearInterval(timer);
		};
	}, []);

	return <Text color="green">{counter} tests passed</Text>;
};

render(<Counter />);

```
<img src="/react/demo.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

you can use the same power of react which is `functional component`, `hooks`, `jsx syntax` etc but now the output is not a DOM nodes rather a terminal UI. 

so host renderer decided how to draw and reconciler gives the optimal answer of what to draw and where to draw ü§Ø


# Why diffing?

Why not just create the new UI from scratch? Because adding elements to the DOM is expensive. Browsers must handle style recalculation, layout (reflow), repaint, and compositing. For complex UIs, creating thousands of elements repeatedly is costly.

<img src="/react/chess.png" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

The diffing algorithm finds **only the minimal part of the UI that needs updating**, avoiding unnecessary operations.


# What if no React?

React is a declarative UI library that automatically syncs state with the rendered UI.

```js
const el = document.createElement("div")
el.textContent = count
document.body.appendChild(el)

button.addEventListener("click", () => {
  count++
  el.textContent = count
})
```

Without React, you‚Äôd manually handle:

* Creating elements
* Updating text
* Wiring updates
* Keeping everything in sync

With React, you simply say:

> ‚ÄúWhen state is `count`, the UI should look like this.‚Äù

React figures out when to re-render, what changed, and how to update the real UI.

# Summary

UI on any platform forms a **tree structure**. React keeps its own version of this tree in memory. When state changes, React builds a new tree, compares it with the old one, and updates **only what actually changed** using platform-specific APIs.

This is how React keeps your data and UI in sync, without manually touching the DOM or native APIs.

<img src="/react/host.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

<img src="/react/connected.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

