---
title: "React Fiber"
description: "rect fiber"
date: "2026-01-26"
topic: "React"
draft: true
---

A while ago scrolling Twitter I stumbled upon this interesting post.


<div className='not-prose flex justify-center'> 
<TweetCard 
  id="1997359890021634509" 
  comments={47}
  reposts={177}
  likes={1400}
  bookmarks={999}
/>

</div>

this is a really good post. it sums so much about react, in the post he mentions this which really had me thinking and i caught my interest to understand more about react

> react finally got freedom from the JS callstack. instead of recursive rendering, it‚Äôs this iterative stepping through fibers one by one. and that suddenly means react can pause. like just literally stop mid render, drop everything, let the browser repaint, handle input, chill, take a breath, then pick up exactly where it left off inside that huge UI tree. no more ‚Äúoh no i‚Äôm stuck deep in recursion‚Äù. you can‚Äôt get stuck because react isn‚Äôt using the builtin stack anymore. it‚Äôs rolling its own.

"react finally got freedom from the JS callstack" ü§î 

to understand the solution we have to know the problem, what was hindering the react performance what did react team came up with, this post explains 
about the react scheduler

# Story of Single thread

We know javascript is a single thread programming language, and for each execution context it only has one thread and a callstack that process
the code line by line. It starts processing from the top to bottom. 


```js 

function doSomethingHeavy() {
  for (let i = 0; i < 1_000_000_000; i++) {} // blocks the thread
  
  console.log("Finished heavy task");
}

doSomethingHeavy();

do_imporatant_task(); // important task
```

from the above example, once the we start the `doSomethingHeavy` task it will run until it finishes but let's say 
we have a important task below, our important task is only executed  once `doSomethingHeavy` loop is finished. 

This is a simple synchronous program, javascript does support a async programming as well, you have probably used `async` `await` in 
javascript. This is done by the [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)

you might suggest we can swap the position of the `doSomethingHeavy()` and `do_imporatant_task()` if we want `do_imporatant_task` to be executed 
first. but right now we know what is important task, you wrote that function, we know what to place where, but what if it was undetermenistic?

when you are running the middle of the heavy task, a really important task pops up, you can't stop the the running program in middle and process something 
you can't empty the callstack suddenly and start working on something else.

Let's see an example,

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function BlockingDemo() {
  const [count, setCount] = useState(0);
  const [isBlocked, setIsBlocked] = useState(false);

  const blockThread = () => {
    setIsBlocked(true);
    
    setTimeout(() => {
      const start = Date.now();
      let dummy = 0;
      
      // Block for 3 seconds
      while (Date.now() - start < 3000) {
        dummy += Math.random();
      }
      
      setIsBlocked(false);
    }, 0);
  };

  return (
    <div className="container">
      <div className="count">{count}</div>
      <div className="buttons">
        <button onClick={blockThread}>
          {isBlocked ? "Processing.." : "Start Work"}
        </button>
        <button onClick={() => setCount(count + 1)}>
          Click +1
        </button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  padding: 30px;
  max-width: 350px;
  margin: 0 auto;
}

.count {
  font-size: 3rem;
  font-weight: 600;
  text-align: center;
  margin-bottom: 20px;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 10px;
}

button {
  flex: 1;
  padding: 12px;
  border: 1px solid #ccc;
  background: white;
  cursor: pointer;
  font-size: 0.9rem;
}

button:hover {
  background: #f5f5f5;
}
`,
"/sandbox.config.json": `{
  "infiniteLoopProtection": false
}`
}}
/>

Try clicking the `click +1` after you press `start work`.  `start work` takes 3 seconds to finish in the time even if you press 
the `click +1` button the count doesn't increment instant, you have to wait it for 3 seconds. this feels laggy and a 
bad user experience.

## What's happening ?



<EventLoopDemo />

when you click a button, that event doesn't directly registeres into a callstack, browser will enqueue the event in the 
macro queue first, once your callstack is empty, eventloop will take the `onClick` task from the queue and push it into the 
callstack.


that's the reason you see increment of number after 3 seconds

I suggest you to study about the event loop and come back to this blog

- [micro task/macro task](https://developer.mozilla.org/en-US/docs/Web/API/HTML_DOM_API/Microtask_guide)




# React of 2016


A time when it was 2016 react used to render everything in sync, everything had equal priority. button clicks, animations
data fetching etc React doesn't run outside the browser, it's just javascript program and it's gonna use the same callstack. 

we have already discussed about react making UI trees during render phase in other [blog](https://inside-react.vercel.app/blog/running-react-on-different-platform)


showing animation where there is a call stack and when user clicks a button it pushes to a microqueue and even loop will fetch and push it into a callstack



react doesn't process everything at once it does one work and now since react has nothing to do

so it's like it process one fiber give it to browser and browser will work, if browser doesn't have anything to do it will 
give back to react, react process another fiber node give back to browser? is that it



Think of it like passing a baton:

React takes the baton ‚Üí starts processing a fiber node (or a chunk of work)

After a short time slice, React yields ‚Üí posts a continuation via MessageChannel

Call stack empties ‚Üí browser gets control

Browser can paint the UI

Browser can handle clicks, scrolls, input events, timers

If nothing urgent happened, the continuation posts back ‚Üí React resumes next fiber node

If a new event happened (like a button click that triggered state update) ‚Üí scheduler now sees a high-priority task ‚Üí may preempt old fiber

So it‚Äôs React ‚Üí Browser ‚Üí React ‚Üí Browser, in small chunks.

