---
title: "React Fiber"
description: "React fiber"
date: "2026-01-26"
topic: "React"
draft: false
---

A while ago, scrolling Twitter, I stumbled upon this interesting post.


<div className='not-prose flex justify-center'> 
<TweetCard 
  id="1997359890021634509" 
  comments={47}
  reposts={177}
  likes={1400}
  bookmarks={999}
/>

</div>

This is a really good post. It sums up so much about React, in the post he mentions this which really had me thinking and it caught my interest to understand more about React

> react finally got freedom from the JS callstack. instead of recursive rendering, it‚Äôs this iterative stepping through fibers one by one. and that suddenly means react can pause. like just literally stop mid render, drop everything, let the browser repaint, handle input, chill, take a breath, then pick up exactly where it left off inside that huge UI tree. no more ‚Äúoh no i‚Äôm stuck deep in recursion‚Äù. you can‚Äôt get stuck because react isn‚Äôt using the builtin stack anymore. it‚Äôs rolling its own.

"react finally got freedom from the JS callstack" ü§î 

this is interesting because what problem would the JS callstack even have so that react had to get rid of it? many people 
will say fiber exist because js is a single thread programming language but it's not an entirely true, 

In this blog we will discuss why the React team chose the fiber approach, and even if we had a multithread model, that wouldn't 
be the best solution for React.


To understand the solution, we have to know the problem: what was hindering React's performance, what the React team came up with. This post explains 
about the React scheduler

# Story of Single thread

We know JavaScript is a single-threaded programming language, and for each execution context it only has one thread and a call stack that processes
the code line by line. It starts processing from the top to bottom. 


```js 

function doSomethingHeavy() {
  for (let i = 0; i < 1_000_000_000; i++) {} // blocks the thread
  
  console.log("Finished heavy task");
}

doSomethingHeavy();

do_imporatant_task(); // important task
```

From the above example, once we start the `doSomethingHeavy` task it will run until it finishes, but let's say 
we have an important task below, our important task is only executed once the `doSomethingHeavy` loop is finished. 

This is a simple synchronous program. JavaScript does support async programming as well, you have probably used `async` `await` in 
JavaScript. This is done by the [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model).

You might suggest we can swap the position of the `doSomethingHeavy()` and `do_imporatant_task()` if we want `do_imporatant_task` to be executed 
first, but right now we know what the important task is. You wrote that function, we know what to place where, but what if it was undeterministic?

When you are running in the middle of a heavy task, a really important task pops up. You can't stop the running program in the middle and process something; 
you can't empty the call stack suddenly and start working on something else.

Let's see an example:

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function BlockingDemo() {
  const [count, setCount] = useState(0);
  const [isBlocked, setIsBlocked] = useState(false);

  const blockThread = () => {
    setIsBlocked(true);
    
    setTimeout(() => {
      const start = Date.now();
      let dummy = 0;
      
      // Block for 3 seconds
      while (Date.now() - start < 3000) {
        dummy += Math.random();
      }
      
      setIsBlocked(false);
    }, 0);
  };

  return (
    <div className="container">
      <div className="count">{count}</div>
      <div className="buttons">
        <button onClick={blockThread}>
          {isBlocked ? "Processing.." : "Start Work"}
        </button>
        <button onClick={() => setCount(count + 1)}>
          Click +1
        </button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  padding: 30px;
  max-width: 350px;
  margin: 0 auto;
}

.count {
  font-size: 3rem;
  font-weight: 600;
  text-align: center;
  margin-bottom: 20px;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 10px;
}

button {
  flex: 1;
  padding: 12px;
  border: 1px solid #ccc;
  background: white;
  cursor: pointer;
  font-size: 0.9rem;
}

button:hover {
  background: #f5f5f5;
}
`,
"/sandbox.config.json": `{
  "infiniteLoopProtection": false
}`
}}
/>

Try clicking the `click +1` after you press `start work`. `start work` takes 3 seconds to finish. In that time, even if you press 
the `click +1` button, the count doesn't increment instantly, you have to wait for 3 seconds. This feels laggy and is a 
bad user experience.


# React 15

React 15 reconciler walked the component tree using recursive function calls. Once it started, it couldn't stop

```jsx
function updateComponent(component) {
  const children = component.render();
  
  children.forEach(child => {
    updateComponent(child); // ‚Üê Recursion
  });
}
```

Every call to `updateComponent` pushes a new frame onto JavaScript's call stack. For a tree with 1,000 components, 
that's 1,000 stack frames, all nested inside each other.

<React15InputDemo />

Imagine there is an input box and whatever the user types in that input box will be reflected on screen. The 
user typed the first character `s`, React will start the rendering process, calling `updateComponent` inside `updateComponent`

doing recursive calls, your call stack is filled with function calls now. While halfway through, the user typed another 
letter `a`, but now you can't stop. It can't say _hold on, the user typed again, let me restart with the new input_ 

JavaScript has no mechanism to pause a call stack, save its state, and resume later. React has to finish processing `s` before it can even see that you 
typed `a`. Each keystroke triggers another full reconciliation. Each time, React is trapped in recursion while your inputs pile up.


This is why React apps felt laggy.

## Priority

<img src="/blog/fiber/slow.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

There was a second problem. React treated all updates equally. A button click got the same priority as a background data fetch. 
An animation got the same priority as logging. 

But some updates are urgent (user typing, clicking) and some can wait (analytics, prefetching). React had no way to express 
this because once reconciliation started, it ran to completion. Everything was equally important because everything blocked 
everything else.

Let's say you fetch some data from the server, a list of 500 products. The response comes back, 
and React starts rendering those 500 items to the screen. Halfway through, maybe 250 products rendered, you type a letter 
in the search box.

What should React do?

Stop rendering those products. Handle the keystroke first. Update the input box immediately. That's what 
the user cares about, seeing their typing reflected instantly.

The products can wait. A 100ms delay in showing search results? Barely noticeable. But a 100ms delay in seeing your keystroke? 
That feels broken.

# Need of solution

The React team thought this was not just going to be a small update, they needed a new way to solve this problem, 
so they wrote a new reconciliation algorithm, which is Fiber

now this new reconciliation algorithm is a whole new re-write based on a cooperative scheduling. React team 
was testing different things and trying to optimize this reconciliation process.

To understand this better, let's look at the original design principles documented by Sebastian Markb√•ge (one of the core React team members):

<div className='not-prose flex justify-center my-6'> 
<GitHubIssueCard 
  owner="facebook" 
  repo="react" 
  issueNumber={7942}
  excerpt="I just wanted to document a few unique design patterns that apply to Fiber. Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm..."
  maxBodyLength={320}
/>
</div>

I will just break down this documentation. If you would like to read it yourself, feel free to do so. 


let's not jump straight into React Fiber, let's try to think ourselves about how we can come up with a solution. 

Now this is an intuition I wanna build up, but if you are in a rush and just wanna read about Fiber, you can skip this part!

We have a few options in our basket, maybe we can use multithreading (web workers). 


The React team thought they needed a solution to this problem. React can't treat every task as equal priority. 
If a user clicks a button, we should halt the rendering process for a while, process that click event 
first, and then continue what we were doing.
