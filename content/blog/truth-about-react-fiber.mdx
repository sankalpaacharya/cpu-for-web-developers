---
title: "React Fiber"
description: "rect fiber"
date: "2026-01-26"
topic: "React"
draft: false
---

A while ago scrolling Twitter I stumbled upon this interesting post.


<div className='not-prose flex justify-center'> 
<TweetCard 
  id="1997359890021634509" 
  comments={47}
  reposts={177}
  likes={1400}
  bookmarks={999}
/>

</div>

this is a really good post. it sums so much about react, in the post he mentions this which really had me thinking and i caught my interest to understand more about react

> react finally got freedom from the JS callstack. instead of recursive rendering, it‚Äôs this iterative stepping through fibers one by one. and that suddenly means react can pause. like just literally stop mid render, drop everything, let the browser repaint, handle input, chill, take a breath, then pick up exactly where it left off inside that huge UI tree. no more ‚Äúoh no i‚Äôm stuck deep in recursion‚Äù. you can‚Äôt get stuck because react isn‚Äôt using the builtin stack anymore. it‚Äôs rolling its own.

"react finally got freedom from the JS callstack" ü§î 

this is interesting because what problem would the JS callstack even have so that react had to get rid of it? many people 
will say fiber exist because js is a single thread programming language but it's not an entirely true, 

In this blog we will dicuss why react team choose the fiber approach and even if we had multithread model that wouldn't 
be the best solution for the react.






to understand the solution we have to know the problem, what was hindering the react performance what did react team came up with, this post explains 
about the react scheduler

# Story of Single thread

We know javascript is a single thread programming language, and for each execution context it only has one thread and a callstack that process
the code line by line. It starts processing from the top to bottom. 


```js 

function doSomethingHeavy() {
  for (let i = 0; i < 1_000_000_000; i++) {} // blocks the thread
  
  console.log("Finished heavy task");
}

doSomethingHeavy();

do_imporatant_task(); // important task
```

from the above example, once the we start the `doSomethingHeavy` task it will run until it finishes but let's say 
we have a important task below, our important task is only executed  once `doSomethingHeavy` loop is finished. 

This is a simple synchronous program, javascript does support a async programming as well, you have probably used `async` `await` in 
javascript. This is done by the [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)

you might suggest we can swap the position of the `doSomethingHeavy()` and `do_imporatant_task()` if we want `do_imporatant_task` to be executed 
first. but right now we know what is important task, you wrote that function, we know what to place where, but what if it was undetermenistic?

when you are running the middle of the heavy task, a really important task pops up, you can't stop the the running program in middle and process something 
you can't empty the callstack suddenly and start working on something else.

Let's see an example,

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function BlockingDemo() {
  const [count, setCount] = useState(0);
  const [isBlocked, setIsBlocked] = useState(false);

  const blockThread = () => {
    setIsBlocked(true);
    
    setTimeout(() => {
      const start = Date.now();
      let dummy = 0;
      
      // Block for 3 seconds
      while (Date.now() - start < 3000) {
        dummy += Math.random();
      }
      
      setIsBlocked(false);
    }, 0);
  };

  return (
    <div className="container">
      <div className="count">{count}</div>
      <div className="buttons">
        <button onClick={blockThread}>
          {isBlocked ? "Processing.." : "Start Work"}
        </button>
        <button onClick={() => setCount(count + 1)}>
          Click +1
        </button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  padding: 30px;
  max-width: 350px;
  margin: 0 auto;
}

.count {
  font-size: 3rem;
  font-weight: 600;
  text-align: center;
  margin-bottom: 20px;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 10px;
}

button {
  flex: 1;
  padding: 12px;
  border: 1px solid #ccc;
  background: white;
  cursor: pointer;
  font-size: 0.9rem;
}

button:hover {
  background: #f5f5f5;
}
`,
"/sandbox.config.json": `{
  "infiniteLoopProtection": false
}`
}}
/>

Try clicking the `click +1` after you press `start work`.  `start work` takes 3 seconds to finish in the time even if you press 
the `click +1` button the count doesn't increment instant, you have to wait it for 3 seconds. this feels laggy and a 
bad user experience.


# React 15

React15 reconciller walked the component tree using the recursive function calls, Once it started it couldn't stop

```jsx
function updateComponent(component) {
  const children = component.render();
  
  children.forEach(child => {
    updateComponent(child); // ‚Üê Recursion
  });
}
```

Every call to `updateComponent` pushes a new frame onto JavaScript's call stack. For a tree with 1,000 components, 
that's 1,000 stack frames, all nested inside each other.

<React15InputDemo />

Imagine, there is a input box and whatever user type on that input box will be reflected on screen 
user typed a first character `s` react will start the rendering process, calling `updateComponent` inside `updateComponent`

doing recursive calls, your callstack is filled with functionCalls now. while halfway through user typed a another 
letter `a` but now you can't stop. It can't say _hold on, the user typed again, let me restart with the new input_ 

JavaScript has no mechanism to pause a call stack, save its state, and resume later. React has to finish processing `s` before it can even see that you 
typed `a`. Each keystroke triggers another full reconciliation. Each time, React is trapped in recursion while your inputs pile up.


This is why React apps felt laggy.

## Priority

<img src="/blog/fiber/slow.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

There was a second problem. React treated all updates equally. A button click got the same priority as a background data fetch. 
An animation got the same priority as logging. 

But some updates are urgent (user typing, clicking) and some can wait (analytics, prefetching). React had no way to express 
this because once reconciliation started, it ran to completion. Everything was equally important because everything blocked 
everything else.

Let's say you fetch some data from the server a list of 500 products. The response comes back, 
and React starts rendering those 500 items to the screen. Halfway through maybe 250 products rendered you type a letter 
in the search box.

What should React do?

stop rendering those products. Handle the keystroke first. Update the input box immediately. That's what 
the user cares about seeing their typing reflected instantly.

The products can wait. A 100ms delay in showing search results? Barely noticeable. But a 100ms delay in seeing your keystroke? 
That feels broken.

# Need of solution

React team thought this is not just going to be an small update, they needed a new way to solve this problem 
so they wrote a new reconciliation algorithm which is fiber

now this new reconciliation algorithm is a whole new re-write based on a cooperative scheduling. React team 
were testing different things and tried to optimize this reconciliation process. 

To understand this better, let's look at the original design principles documented by Sebastian Markb√•ge (one of the core React team members):

<div className='not-prose flex justify-center my-6'> 
<GitHubIssueCard 
  owner="facebook" 
  repo="react" 
  issueNumber={7942}
  excerpt="I just wanted to document a few unique design patterns that apply to Fiber. Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm..."
  maxBodyLength={320}
/>
</div>

I will just breakdown this documention, if you would like to read it by yourself feel free to do so. 


let's not jump straight in into the react fiber, let's try to think of ourselves how we can come up with? 

now this is an intution i wanna build up but if you are in rush and just wanna read fiber you can skip this part!

we have a few options in our basket, maybe we can use multithread(webworkers), 


React team thought we need a solution to this problem, React can't treat every task as a equal priority 
if user clicks a button, we should halt the rendering process for a while, process that click event 
first and then continue what we were
