---
title: "React Fiber"
description: "rect fiber"
date: "2026-01-26"
topic: "React"
draft: true
---

A while ago scrolling Twitter I stumbled upon this interesting post.


<div className='not-prose flex justify-center'> 
<TweetCard 
  id="1997359890021634509" 
  comments={47}
  reposts={177}
  likes={1400}
  bookmarks={999}
/>

</div>

this is a really good post. it sums so much about react, in the post he mentions this which really had me thinking and i caught my interest to understand more about react

> react finally got freedom from the JS callstack. instead of recursive rendering, it‚Äôs this iterative stepping through fibers one by one. and that suddenly means react can pause. like just literally stop mid render, drop everything, let the browser repaint, handle input, chill, take a breath, then pick up exactly where it left off inside that huge UI tree. no more ‚Äúoh no i‚Äôm stuck deep in recursion‚Äù. you can‚Äôt get stuck because react isn‚Äôt using the builtin stack anymore. it‚Äôs rolling its own.

"react finally got freedom from the JS callstack" ü§î 

this is interesting because why problem would the JS callstack even have so that react had to get rid of it? 

To understand this better, let's look at the original design principles documented by Sebastian Markb√•ge (one of the core React team members):

<div className='not-prose flex justify-center my-6'> 
<GitHubIssueCard 
  owner="facebook" 
  repo="react" 
  issueNumber={7942}
  excerpt="I just wanted to document a few unique design patterns that apply to Fiber. Nothing in Fiber uses the normal JS stack. Meaning it does use the stack but it can be compiled into a flat function if needed. If I can't use recursion, how do I traverse through the tree? Learn to use the singly linked list tree traversal algorithm..."
  maxBodyLength={320}
/>
</div>

## goal is to explain recursive approach was bad not to explain event loop, goal is to explain reader why we needed a 
## another solution

to understand the solution we have to know the problem, what was hindering the react performance what did react team came up with, this post explains 
about the react scheduler

# Story of Single thread

We know javascript is a single thread programming language, and for each execution context it only has one thread and a callstack that process
the code line by line. It starts processing from the top to bottom. 


```js 

function doSomethingHeavy() {
  for (let i = 0; i < 1_000_000_000; i++) {} // blocks the thread
  
  console.log("Finished heavy task");
}

doSomethingHeavy();

do_imporatant_task(); // important task
```

from the above example, once the we start the `doSomethingHeavy` task it will run until it finishes but let's say 
we have a important task below, our important task is only executed  once `doSomethingHeavy` loop is finished. 

This is a simple synchronous program, javascript does support a async programming as well, you have probably used `async` `await` in 
javascript. This is done by the [event loop](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Execution_model)

you might suggest we can swap the position of the `doSomethingHeavy()` and `do_imporatant_task()` if we want `do_imporatant_task` to be executed 
first. but right now we know what is important task, you wrote that function, we know what to place where, but what if it was undetermenistic?

when you are running the middle of the heavy task, a really important task pops up, you can't stop the the running program in middle and process something 
you can't empty the callstack suddenly and start working on something else.

Let's see an example,

<Sandpack
template="react"
files={{
"/App.js": `import { useState } from "react";

export default function BlockingDemo() {
  const [count, setCount] = useState(0);
  const [isBlocked, setIsBlocked] = useState(false);

  const blockThread = () => {
    setIsBlocked(true);
    
    setTimeout(() => {
      const start = Date.now();
      let dummy = 0;
      
      // Block for 3 seconds
      while (Date.now() - start < 3000) {
        dummy += Math.random();
      }
      
      setIsBlocked(false);
    }, 0);
  };

  return (
    <div className="container">
      <div className="count">{count}</div>
      <div className="buttons">
        <button onClick={blockThread}>
          {isBlocked ? "Processing.." : "Start Work"}
        </button>
        <button onClick={() => setCount(count + 1)}>
          Click +1
        </button>
      </div>
    </div>
  );
}`,
"/styles.css": `.container {
  padding: 30px;
  max-width: 350px;
  margin: 0 auto;
}

.count {
  font-size: 3rem;
  font-weight: 600;
  text-align: center;
  margin-bottom: 20px;
  font-family: monospace;
}

.buttons {
  display: flex;
  gap: 10px;
}

button {
  flex: 1;
  padding: 12px;
  border: 1px solid #ccc;
  background: white;
  cursor: pointer;
  font-size: 0.9rem;
}

button:hover {
  background: #f5f5f5;
}
`,
"/sandbox.config.json": `{
  "infiniteLoopProtection": false
}`
}}
/>

Try clicking the `click +1` after you press `start work`.  `start work` takes 3 seconds to finish in the time even if you press 
the `click +1` button the count doesn't increment instant, you have to wait it for 3 seconds. this feels laggy and a 
bad user experience.


# React of 2016


A time when it was 2016 react used to render everything in sync, everything had equal priority. button clicks, animations
data fetching etc React is just javascript program and it's gonna use the same callstack. 

it was a recursive process once it starts rendering there is no way we can stop, once rendering started 
we are handling over the js thread to a react program, it will begin processing the UI tree from top to bottom.

this design decission dommed once the react apps got big, rendering took time

<img src="/blog/fiber/slow.svg" alt="React UI Runtime" width="800" height="100" style={{ display: 'block', margin: '2rem auto' }} />

while processing user clicks a button, browser will enqueue that event into a queue and waits till the callstack is empty 
but react is holding the js thread doing rendering, while user sits there and wonders why my button is not working 
why this is so slow.

it's not just button click only,input events, it would be scroll event, it would a animations, if each user interactions are not 
instant it might feel application is laggy and slow.

we have already discussed about react making UI trees during render phase in other [blog](https://inside-react.vercel.app/blog/running-react-on-different-platform)

# Solution we need

React team thought we need a solution to this problem, React can't treat every task as a equal priority 
if user clicks a button, we should halt the rendering process for a while, process that click event 
first and then continue what we were

# ‚ÄúThe event loop isn‚Äôt blocking React. React is blocking the event loop.‚Äù


react doesn't process everything at once it does one work and now since react has nothing to do

so it's like it process one fiber give it to browser and browser will work, if browser doesn't have anything to do it will 
give back to react, react process another fiber node give back to browser? is that it


Think of it like passing a baton:

React takes the baton ‚Üí starts processing a fiber node (or a chunk of work)

After a short time slice, React yields ‚Üí posts a continuation via MessageChannel

Call stack empties ‚Üí browser gets control

Browser can paint the UI

Browser can handle clicks, scrolls, input events, timers

If nothing urgent happened, the continuation posts back ‚Üí React resumes next fiber node

If a new event happened (like a button click that triggered state update) ‚Üí scheduler now sees a high-priority task ‚Üí may preempt old fiber

So it‚Äôs React ‚Üí Browser ‚Üí React ‚Üí Browser, in small chunks.

